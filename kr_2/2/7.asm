; demagogen, [20.05.2025 11:12]
; Используя логические команды и команды работы со стеком, поменять значение флага SF (7-й бит справа – нумерация битов от 0) и ZF (6-й бит 
; справа) на противоположные. 
; Проверить.

; Для этого введите значения переменных a и b, размером - слово без знака, затем выполните команду

; mov ax, [a]

; sub ax, [b]

; при выполнении последней команды сформируются флаги, в том числе, SF и ZF.

; Поменяйте их значения на противоположные, не меняя значения всех остальных флагов. Распечатайте полученные значения в виде:

; SF = значение флага sf

; ZF = значение флага zf.

; Обратите внимание на пробелы при печати.

; Для ввода и вывода использовать функции scanf и printf.

; Архитектура 64-х разрядная

; Пример:

; Ввод


; вывод

; 5

; 10


; SF = 0

; ZF = 1

; #номер2

; Zevs Grom, [20.05.2025 11:12]
; Рома, кидай нормально, через `

; demagogen, [20.05.2025 11:12]
global main
extern scanf
extern printf

section .data
    input_format db "%hu %hu", 0  ; Формат для ввода двух беззнаковых слов
    output_format db "SF = %d", 0xA, "ZF = %d", 0xA, 0

    a dw 0
    b dw 0
section .text
main:
    ; Выравниваем стек
    push rbp

    mov rbp, rsp
    sub rsp, 32
    ; Вводим значения a и b

    lea rdi, [input_format]
    lea rsi, [a]
    lea rdx, [b]
    xor eax, eax
    call scanf
    ; Выполняем операцию, которая установит флаги
    mov ax, [a]
    sub ax, [b]      ; Здесь устанавливаются флаги SF и ZF

    ; Сохраняем все флаги
    pushfq           ; Помещаем флаги в стек (64 бита)

    ; Достаем флаги в регистр RAX
    pop rax
    ; Копируем флаги в RBX для модификации
    mov rbx, rax

    ; Инвертируем SF (7-й бит)

    xor rbx, 1 << 7  ; XOR с маской 10000000b
    ; Инвертируем ZF (6-й бит)
    xor rbx, 1 << 6  ; XOR с маской 01000000b

    ; Сохраняем модифицированные флаги обратно
    push rbx
    popfq            ; Загружаем модифицированные флаги
    ; Теперь получаем значения SF и ZF для вывода
    ; SF находится в 7-м бите EFLAGS
    setc cl          ; Устанавливаем CL=1 если CF=1 (нам не нужно)
    sets cl          ; Устанавливаем CL=1 если SF=1
    movzx r8d, cl    ; Сохраняем значение SF в R8D

    ; ZF находится в 6-м бите EFLAGS

    setz cl          ; Устанавливаем CL=1 если ZF=1
    movzx r9d, cl    ; Сохраняем значение ZF в R9D
    ; Выводим результаты
    lea rdi, [output_format]
    mov esi, r8d     ; SF
    mov edx, r9d     ; ZF
    xor eax, eax
    call printf

    ; Восстанавливаем стек и выходим
    mov rsp, rbp
    pop rbp
    xor eax, eax
    ret